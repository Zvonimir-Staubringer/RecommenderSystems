import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
from sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer
from sklearn.metrics.pairwise import linear_kernel, cosine_similarity
from sklearn.metrics import mean_absolute_error, mean_squared_error

warnings.filterwarnings('ignore')

# Učitaj podatke
books = pd.read_csv('GoodReads/books.csv')
ratings = pd.read_csv('GoodReads/ratings.csv')
book_tags = pd.read_csv('GoodReads/book_tags.csv')
tags = pd.read_csv('GoodReads/tags.csv')

# Priprema godina
books['original_publication_year'] = books['original_publication_year'].fillna(-1).apply(lambda x: int(x) if x != -1 else -1)

# Makni duplikate iz ratings
ratings_rmv_duplicates = ratings.drop_duplicates()
unwanted_users = ratings_rmv_duplicates.groupby('user_id')['user_id'].count()
unwanted_users = unwanted_users[unwanted_users < 3]
unwanted_ratings = ratings_rmv_duplicates[ratings_rmv_duplicates.user_id.isin(unwanted_users.index)]
new_ratings = ratings_rmv_duplicates.drop(unwanted_ratings.index)

# Dodaj naslov knjige u ratings
new_ratings['title'] = books.set_index('id').title.loc[new_ratings.book_id].values

# Definiraj žanrove
genres = ["Art", "Biography", "Business", "Chick Lit", "Children's", "Christian", "Classics",
          "Comics", "Contemporary", "Cookbooks", "Crime", "Ebooks", "Fantasy", "Fiction",
          "Gay and Lesbian", "Graphic Novels", "Historical Fiction", "History", "Horror",
          "Humor and Comedy", "Manga", "Memoir", "Music", "Mystery", "Nonfiction", "Paranormal",
          "Philosophy", "Poetry", "Psychology", "Religion", "Romance", "Science", "Science Fiction", 
          "Self Help", "Suspense", "Spirituality", "Sports", "Thriller", "Travel", "Young Adult"]

# Strip spaces and convert authors to lowercase
books['authors'] = books['authors'].str.replace(' ', '').str.lower()

# --- Smanji podatkovni skup za bržu analizu ---
# Koristi samo prvih 5000 knjiga i ocjena tih knjiga
books_small = books.iloc[:5000].copy()
book_ids_small = set(books_small['id'])
ratings_small = new_ratings[new_ratings['book_id'].isin(book_ids_small)].copy()

# Priprema žanrova za svaku knjigu (spoji tagove prema goodreads_book_id)
book_tags_merged = pd.merge(book_tags, tags, left_on='tag_id', right_on='tag_id', how='left')
if 'goodreads_book_id' in book_tags_merged.columns:
    book_genres = book_tags_merged[book_tags_merged['goodreads_book_id'].isin(book_ids_small)]
    book_genres = book_genres.groupby('goodreads_book_id')['tag_name'].apply(lambda x: ' '.join(x.astype(str))).reset_index()
    books_small = pd.merge(books_small, book_genres, left_on='id', right_on='goodreads_book_id', how='left')
else:
    book_genres = book_tags_merged[book_tags_merged['book_id'].isin(book_ids_small)]
    book_genres = book_genres.groupby('book_id')['tag_name'].apply(lambda x: ' '.join(x.astype(str))).reset_index()
    books_small = pd.merge(books_small, book_genres, left_on='id', right_on='book_id', how='left')
books_small['tag_name'] = books_small['tag_name'].fillna('')

# Kombiniraj naslov, autora, opis i žanrove
if 'description' in books_small.columns:
    books_small['description'] = books_small['description'].fillna('')
    books_small['content'] = books_small['title'] + ' ' + books_small['authors'] + ' ' + books_small['description'] + ' ' + books_small['tag_name']
else:
    books_small['content'] = books_small['title'] + ' ' + books_small['authors'] + ' ' + books_small['tag_name']

# Count Vectorizer za count matrix
count = CountVectorizer(stop_words='english')
count_matrix = count.fit_transform(books_small['content'])

# Cosine similarity
cosine_sim = cosine_similarity(count_matrix, count_matrix)

# Mapiranje indeksa
indices = pd.Series(books_small.index, index=books_small['title']).drop_duplicates()

def get_book_recommendations(title, top_n=10):
    idx = indices.get(title)
    if idx is None:
        print("Knjiga nije pronađena.")
        return []
    sim_scores = list(enumerate(np.asarray(cosine_sim[idx]).flatten()))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    valid_indices = [i[0] for i in sim_scores[1:top_n+1] if i[0] < len(books_small)]
    return books_small['title'].iloc[valid_indices].tolist()

# Primjer korištenja
print("Preporucene knjige za 'The Hobbit':")
for title in get_book_recommendations('The Hobbit', top_n=5):
    print(title)

# Pripremi mapu: book_id -> title
bookid_to_title = books_small.set_index('id')['title'].dropna().to_dict()
title_to_bookid = {v: k for k, v in bookid_to_title.items()}

# Evaluacija: MAE, RMSE, Precision@N, MAP
N = 10
user_counts_to_test = [500, 1000, 2000, 4000, 6000]
results = []

for max_users in user_counts_to_test:
    user_precision = []
    user_map = []
    all_true = []
    all_pred = []
    user_count = 0
    for user_id, group in ratings_small.groupby('user_id'):
        if user_count >= max_users:
            break
        user_count += 1
        rated_titles = group['book_id'].map(bookid_to_title).dropna().tolist()
        if not rated_titles:
            continue
        query_title = rated_titles[0]
        recommended = get_book_recommendations(query_title, top_n=N)
        relevant = set(rated_titles)
        pred = set(recommended)
        true_positives = len(relevant & pred)
        precision = true_positives / N if N > 0 else 0
        user_precision.append(precision)
        hits = 0
        sum_precisions = 0
        for i, rec in enumerate(recommended):
            if rec in relevant:
                hits += 1
                sum_precisions += hits / (i + 1)
        ap = sum_precisions / min(len(relevant), N) if relevant else 0
        user_map.append(ap)
        pred_rating = group[group['book_id'] == title_to_bookid.get(query_title, -1)]['rating'].mean()
        for t in recommended:
            true_rating = group[group['book_id'] == title_to_bookid.get(t, -1)]['rating']
            if not true_rating.empty:
                all_true.append(true_rating.values[0])
                all_pred.append(pred_rating if not np.isnan(pred_rating) else 3.0)
    if all_true and all_pred:
        mae = mean_absolute_error(all_true, all_pred)
        rmse = np.sqrt(mean_squared_error(all_true, all_pred))
    else:
        mae = None
        rmse = None
    precision_val = np.mean(user_precision) if user_precision else None
    map_val = np.mean(user_map) if user_map else None
    results.append({
        'users': max_users,
        'MAE': mae,
        'RMSE': rmse,
        'Precision@N': precision_val,
        'MAP': map_val
    })
    # Zamijeni f-string formatiranje za None vrijednosti
    mae_str = f"{mae:.4f}" if mae is not None else "None"
    rmse_str = f"{rmse:.4f}" if rmse is not None else "None"
    precision_str = f"{precision_val:.4f}" if precision_val is not None else "None"
    map_str = f"{map_val:.4f}" if map_val is not None else "None"
    print(f"Evaluacija za {max_users} korisnika: MAE={mae_str}, RMSE={rmse_str}, Precision@{N}={precision_str}, MAP={map_str}")

# Grafički prikaz
users = [r['users'] for r in results]
mae_vals = [r['MAE'] if r['MAE'] is not None else np.nan for r in results]
rmse_vals = [r['RMSE'] if r['RMSE'] is not None else np.nan for r in results]
precision_vals = [r['Precision@N'] if r['Precision@N'] is not None else np.nan for r in results]
map_vals = [r['MAP'] if r['MAP'] is not None else np.nan for r in results]

plt.figure(figsize=(12,6))
plt.plot(users, np.round(mae_vals, 4), marker='o', label='MAE')
plt.plot(users, np.round(rmse_vals, 4), marker='o', label='RMSE')
plt.plot(users, np.round(precision_vals, 4), marker='o', label=f'Precision@{N}')
plt.plot(users, np.round(map_vals, 4), marker='o', label='MAP')
plt.xlabel('Broj korisnika')
plt.ylabel('Vrijednost metrike')
plt.title('Evaluacija sustava za različit broj korisnika')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
